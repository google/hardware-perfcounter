/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "context.h"

#include <stdint.h>
#include <string.h>
#include <unistd.h>  // For close

#include "driver_ioctl.h"
#include "hpc/gpu/base_utilities.h"

const uint32_t NUM_COUNTERS_PER_CATEGORY = 64;

//===-------------- BEGIN AUTOGENERATED REGION; DO NOT EDIT! --------------===//

hpc_gpu_mali_counter_layout_t hpc_gpu_mali_get_counter_layout(uint16_t gpu_id) {
  if ((gpu_id & 0xf00fu) == 0x9005u) return HPC_GPU_MALI_COUNTER_LAYOUT_TBOX;
  if ((gpu_id & 0xf00fu) == 0x9002u) return HPC_GPU_MALI_COUNTER_LAYOUT_TBOX;
  if ((gpu_id & 0xf00fu) == 0x9004u) return HPC_GPU_MALI_COUNTER_LAYOUT_TOTX;
  if ((gpu_id & 0xf00fu) == 0x9000u) return HPC_GPU_MALI_COUNTER_LAYOUT_TTRX;
  if ((gpu_id & 0xf00fu) == 0x9003u) return HPC_GPU_MALI_COUNTER_LAYOUT_TNAX;
  if ((gpu_id & 0xf00fu) == 0x9001u) return HPC_GPU_MALI_COUNTER_LAYOUT_TNAX;
  if ((gpu_id & 0xf00fu) == 0x7001u) return HPC_GPU_MALI_COUNTER_LAYOUT_TNOX;
  if ((gpu_id & 0xf00fu) == 0x7002u) return HPC_GPU_MALI_COUNTER_LAYOUT_TGOX;
  if ((gpu_id & 0xf00fu) == 0x7000u) return HPC_GPU_MALI_COUNTER_LAYOUT_TSIX;
  if ((gpu_id & 0xf00fu) == 0x7003u) return HPC_GPU_MALI_COUNTER_LAYOUT_TDVX;
  if ((gpu_id & 0xf00fu) == 0x6001u) return HPC_GPU_MALI_COUNTER_LAYOUT_THEX;
  if ((gpu_id & 0xf00fu) == 0x6000u) return HPC_GPU_MALI_COUNTER_LAYOUT_TMIX;
  if ((gpu_id & 0xffffu) == 0x0880u) return HPC_GPU_MALI_COUNTER_LAYOUT_T88X;
  if ((gpu_id & 0xffffu) == 0x0860u) return HPC_GPU_MALI_COUNTER_LAYOUT_T86X;
  if ((gpu_id & 0xffffu) == 0x0830u) return HPC_GPU_MALI_COUNTER_LAYOUT_T83X;
  if ((gpu_id & 0xffffu) == 0x0820u) return HPC_GPU_MALI_COUNTER_LAYOUT_T82X;
  return HPC_GPU_MALI_COUNTER_LAYOUT_UNKNOWN;
}

typedef enum mali_counter_category_e {
  MALI_COUNTER_CATEGORY_JOB_MANAGER = 0,
  MALI_COUNTER_CATEGORY_TILER = 1,
  MALI_COUNTER_CATEGORY_SHADER_CORE = 2,
  MALI_COUNTER_CATEGORY_MEMORY = 3,
} mali_counter_category_t;

static inline mali_counter_category_t mali_get_counter_category(
    uint32_t counter) {
  return counter >> 8u;
}

//===--------------- END AUTOGENERATED REGION; DO NOT EDIT! ---------------===//

typedef struct hpc_gpu_mali_context_t {
  /// The buffer containing all counter values returned from the driver for
  /// one sample.
  uint32_t *query_buffer;
  /// The list of counter categories.
  uint32_t *counter_categories;
  /// The list of counter indices (into their categories).
  uint32_t *counter_indices;
  /// The number of counters.
  uint32_t num_counters;

  /// The current GPU's file descriptor.
  int gpu_device;
  /// The indices of enabled shader cores of the current GPU.
  uint32_t *shader_core_indices;
  /// The number of shader cores of the current GPU.
  uint32_t num_shader_cores;

  /// The current GPU's information.
  hpc_gpu_mali_ioctl_gpu_device_info_t device_info;

  /// The current counter reader.
  struct hpc_gpu_mali_ioctl_counter_reader_t counter_reader;
} hpc_gpu_mali_context_t;

static uint32_t popcount(uint32_t x) {
  uint32_t count = 0;
  for (; x != 0; x >>= 1) count += (x & 1u);
  return count;
}

int hpc_gpu_mali_create_context(
    uint32_t num_counters, uint32_t *counters,
    convert_counter_fn convert_counter,
    const hpc_gpu_host_allocation_callbacks_t *allocator,
    hpc_gpu_mali_context_t **out_context) {
  int gpu_device = hpc_gpu_mali_ioctl_open_gpu_device();
  if (gpu_device < 0) return gpu_device;

  // First negotiate API version with the kernel driver. Feeding in 0.0 means to
  // accept whatever version the kernel driver is at, as it does not really
  // matter for us. But we still need to perform this step because the kernel
  // driver needs to initialize API version inside.
  uint16_t major_version = 0, minor_version = 0;
  int status = hpc_gpu_mali_ioctl_setup_api_version(gpu_device, &major_version,
                                                    &minor_version);
  if (status < 0) return status;

  // Then setup the kernel API context. This is also necessary for future
  // interactions with the kernel driver.
  status = hpc_gpu_mali_ioctl_setup_api_context(gpu_device);
  if (status < 0) return status;

  // Query device information to figure out which GPU product this is.
  hpc_gpu_mali_ioctl_gpu_device_info_t device_info;
  status = hpc_gpu_mali_ioctl_get_gpu_device_info(gpu_device, allocator,
                                                  &device_info);
  if (status < 0) return status;

  hpc_gpu_mali_counter_layout_t layout =
      hpc_gpu_mali_get_counter_layout((uint16_t)device_info.gpu_product_id);
  if (layout == HPC_GPU_MALI_COUNTER_LAYOUT_UNKNOWN) {
    return -HPC_GPU_ERROR_UNKNOWN_DEVICE;
  }

  // Now it's time to set up the counter reader.
  hpc_gpu_mali_ioctl_counter_reader_t counter_reader;
  status = hpc_gpu_mali_ioctl_open_counter_reader(gpu_device, &counter_reader);
  if (status < 0) return status;

  // Allocate memory for the context itself.
  hpc_gpu_mali_context_t *context =
      allocator->alloc(allocator->user_data, sizeof(hpc_gpu_mali_context_t));

  context->num_counters = num_counters;
  context->gpu_device = gpu_device;
  context->num_shader_cores = popcount(device_info.shader_core_mask);
  context->device_info = device_info;
  context->counter_reader = counter_reader;

  // Allocate memory for the embedded buffer containing counter categories and
  // indices.
  uint32_t *categories =
      allocator->alloc(allocator->user_data, num_counters * sizeof(uint32_t));
  uint32_t *indices =
      allocator->alloc(allocator->user_data, num_counters * sizeof(uint32_t));
  for (int i = 0; i < num_counters; ++i) {
    categories[i] = mali_get_counter_category(counters[i]);
    indices[i] = convert_counter(counters[i], layout);
  }
  context->counter_categories = categories;
  context->counter_indices = indices;

  // Allocate memory for enabled shader core indices.
  context->shader_core_indices = allocator->alloc(
      allocator->user_data, context->num_shader_cores * sizeof(uint32_t));
  for (uint32_t index = 0, i = 0; i < 32; ++i) {
    if (device_info.shader_core_mask & (1u << i)) {
      context->shader_core_indices[index++] = i;
    }
  }

  // Allocate memory for the embedded buffer for sampling counters.
  context->query_buffer =
      allocator->alloc(allocator->user_data, counter_reader.single_buffer_size);
  memset(context->query_buffer, 0, counter_reader.single_buffer_size);

  *out_context = context;
  return 0;
}

int hpc_gpu_mali_destroy_context(
    hpc_gpu_mali_context_t *context,
    const hpc_gpu_host_allocation_callbacks_t *allocator) {
  int status =
      hpc_gpu_mali_ioctl_close_counter_reader(&context->counter_reader);
  if (status < 0) return status;
  status = hpc_gpu_mali_ioctl_close_gpu_device(context->gpu_device);
  if (status < 0) return status;

  allocator->free(allocator->user_data, context->query_buffer);
  allocator->free(allocator->user_data, context->counter_indices);
  allocator->free(allocator->user_data, context);
  return 0;
}

int hpc_gpu_mali_context_start_counters(const hpc_gpu_mali_context_t *context) {
  return hpc_gpu_mali_ioctl_zero_counters(&context->counter_reader);
}

int hpc_gpu_mali_context_stop_counters(const hpc_gpu_mali_context_t *context) {
  // Nothing to do.
  return 0;
}

int hpc_gpu_mali_context_query_counters(const hpc_gpu_mali_context_t *context,
                                        uint64_t *values) {
  // Get a new sample of all perf counters.
  uint64_t timestamp = 0;
  int status = hpc_gpu_mali_ioctl_query_counters(
      &context->counter_reader, context->query_buffer, &timestamp);
  if (status < 0) return status;

  // Extract those requested during context creation and write out.
  //
  // Note that the kernel driver just returns a packed buffer containing counter
  // samples for all functionality blocks, in the order of the job manager, the
  // tiler, all L2 slices, all shader cores. Each functionality block are
  // guaranteed to return 64 32-bit counters. If there are more than one L2
  // slide, they each emit 64 counters so we need to aggregate. Further, for
  // shader cores, the driver always return 32 (the bitwidth of the core mask)
  // blocks. But those shader cores off in the mask aren't enabled; their blocks
  // should be skipped.
  for (int i = 0; i < context->num_counters; ++i) {
    switch ((mali_counter_category_t)context->counter_categories[i]) {
      case MALI_COUNTER_CATEGORY_JOB_MANAGER: {
        values[i] = context->query_buffer[context->counter_indices[i]];
      } break;
      case MALI_COUNTER_CATEGORY_TILER: {
        uint32_t offset =
            NUM_COUNTERS_PER_CATEGORY + context->counter_indices[i];
        values[i] = context->query_buffer[offset];
      } break;
      case MALI_COUNTER_CATEGORY_MEMORY: {
        uint64_t total = 0;
        uint32_t base_offset = NUM_COUNTERS_PER_CATEGORY * 2;
        for (int j = 0; j < context->device_info.num_l2_slices; ++j) {
          uint32_t offset = base_offset + NUM_COUNTERS_PER_CATEGORY * j +
                            context->counter_indices[i];
          total += context->query_buffer[offset];
        }
        values[i] = total;
      } break;
      case MALI_COUNTER_CATEGORY_SHADER_CORE: {
        uint64_t total = 0;
        uint32_t base_offset = NUM_COUNTERS_PER_CATEGORY *
                               (2 + context->device_info.num_l2_slices);
        for (int j = 0; j < context->num_shader_cores; ++j) {
          uint32_t offset =
              base_offset +
              NUM_COUNTERS_PER_CATEGORY * context->shader_core_indices[j] +
              context->counter_indices[i];
          total += context->query_buffer[offset];
        }
        values[i] = total;
      } break;
    }
  }

  return 0;
}
