#!/usr/bin/env python3

import argparse
import os
import re

import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Dict, Tuple

# Known acronyms that should be kept as all capitals
ADRENO_ACRONYMS = ["ALU", "EFU", "GPR"]
# Mappings from known group acronyms to their IDs used in the kernel driver
ADRENO_PERFCOUNTER_GROUP_IDS = {
    "CP": 0x0,
    "RBBM": 0x1,
    "PC": 0x2,
    "VFD": 0x3,
    "HLSQ": 0x4,
    "VPC": 0x5,
    "TSE": 0x6,
    "RAS": 0x7,
    "UCHE": 0x8,
    "TP": 0x9,
    "SP": 0xA,
    "RB": 0xB,
    "PWR": 0xC,
    "VBIF": 0xD,
    "VBIF_PWR": 0xE,
    "MH": 0xF,
    "PA_SU": 0x10,
    "SQ": 0x11,
    "SX": 0x12,
    "TCF": 0x13,
    "TCM": 0x14,
    "TCR": 0x15,
    "L2": 0x16,
    "VSC": 0x17,
    "CCU": 0x18,
    "LRZ": 0x19,
    "CMP": 0x1A,
    "ALWAYSON": 0x1B,
    "SP_PWR": 0x1C,
    "TP_PWR": 0x1D,
    "RB_PWR": 0x1E,
    "CCU_PWR": 0x1F,
    "UCHE_PWR": 0x20,
    "CP_PWR": 0x21,
    "GPMU_PWR": 0x22,
    "ALWAYSON_PWR": 0x23,
    "GLC": 0x24,
    "FCHE": 0x25,
    "MHUB": 0x26,
}
# Mappings from known group acronyms to their full names
ADRENO_PERFCOUNTER_GROUP_NAMES = {
    "CCU": "Cache and Compression Unit",
    "CP": "Command Parser",
    "HLSQ": "High Level SeQuencer",
    "LRZ": "Low Resolution Z",
    "SP": "Shader/Streaming Processor",
    "TP": "Texture Processor",
    "TSE": "Triangle Setup Engine",
    "UCHE": "Unified L2 Cache",
}
# Namespace prefixes used in Freedreno's envytool definition
ADRENO_XML_NS = {"nouveau": "http://nouveau.freedesktop.org/"}

# The maximal number of counters per group
# This is used to offset counter IDs when putting all counters in the same
# C enum.
ADRENO_MAX_NUM_COUNTER_BIT_PER_GROUP = 8

ADRENO_AUTOGEN_MARKER = "AUTOGENERATED REGION; DO NOT EDIT!"

# Code templates for generating perfcounter C enums
ADRENO_C_ENUM = """
/// Perfcounter choices for Adreno {upper_series} series.
typedef enum hpc_gpu_adreno_{series}_perfcounter_e {{
  {cases}
}} hpc_gpu_adreno_{series}_perfcounter_t;

"""
ADRENO_C_ENUM_CASE = "HPC_GPU_ADRENO_{series}_{group}_{symbol}"
ADRENO_C_ENUM_CASE_VALUE = "HPC_GPU_ADRENO_{series}_{group}_{symbol} = {value},"

# Code templates for generating perfcounter conversion functions
ADRENO_ENUM_VALUE_TO_SELECTOR_DIRECT_FN = """
static inline uint32_t adreno_{series}_perfcounter_get_selector(
    hpc_gpu_adreno_{series}_perfcounter_t perfcounter) {{
  {selector_logic}
}}
"""
ADRENO_ENUM_VALUE_TO_SELECTOR_SWITCH_FN = """
static uint32_t adreno_common_perfcounter_convert_to_{series}(
    hpc_gpu_adreno_common_perfcounter_t perfcounter) {{
  // clang-format off
  switch (perfcounter) {{
    {cases}
  }}
  // clang-format on
}}
"""
ADRENO_ENUM_VALUE_TO_GROUP_FN = """
static inline uint32_t adreno_{series}_perfcounter_get_group(
    hpc_gpu_adreno_{series}_perfcounter_t perfcounter) {{
  {group_logic}
}}
"""


@dataclass
class AdrenoPerfCounter:
  """A data class containing one Adreno perf counter."""
  name: str  # Perfcounter name
  symbol: str  # Perfcounter C enum symbol
  selector: int  # Perfcounter selector ID


@dataclass
class AdrenoPerSeriesDefinition:
  """A data class containing all performance counters for one Andreo series."""
  series: str
  # {group-name -> {perfcounter-symbol -> perfcounter}}
  groups: Dict[str, Dict[str, AdrenoPerfCounter]]

  def __str__(self):
    lines = [f"Series: {self.series}"]
    for group_name, group in self.groups.items():
      lines.append(f"  PerfCounter Group: '{group_name}'")
      for _, case in group.items():
        lines.append(f"    {case.selector} -> {case.symbol} ({case.name})")
    return "\n".join(lines)

  def get_all_perfcounters_as_one_enum(self):
    """Returns one C enum definition for all groups' perf counters.

    This puts all perf counters in all groups in one flat C enum. Each group
    is assumed to have less than 2^ADRENO_MAX_NUM_COUNTER_BIT_PER_GROUP, which
    is used to assign value ranges.
    """
    known_groups = [
        item for item in self.groups.items()
        if ADRENO_PERFCOUNTER_GROUP_IDS.get(item[0]) is not None
    ]
    uknown_groups = [
        item[0]
        for item in self.groups.items()
        if ADRENO_PERFCOUNTER_GROUP_IDS.get(item[0]) is None
    ]
    if len(uknown_groups) != 0:
      print(f"  warning: {self.series} UKNOWN groups: {uknown_groups}")

    cases = []
    sorted_groups = sorted(
        known_groups, key=lambda item: ADRENO_PERFCOUNTER_GROUP_IDS[item[0]])
    for group_name, group in sorted_groups:
      if len(group) >= 2**ADRENO_MAX_NUM_COUNTER_BIT_PER_GROUP:
        raise ValueError("Max counter count per group exceeded!")
      full_group_name = ADRENO_PERFCOUNTER_GROUP_NAMES.get(
          group_name, group_name)
      for case in group.values():
        # Offset the symbol's value by its group
        value = case.selector + (2**ADRENO_MAX_NUM_COUNTER_BIT_PER_GROUP *
                                 ADRENO_PERFCOUNTER_GROUP_IDS[group_name])
        cases.append(f"/// {full_group_name}: {case.name}")
        cases.append(
            ADRENO_C_ENUM_CASE_VALUE.format(series=self.series.upper(),
                                            group=group_name,
                                            symbol=case.symbol,
                                            value=value))
    return ADRENO_C_ENUM.format(series=self.series,
                                upper_series=self.series.upper(),
                                cases="\n  ".join(cases))

  def get_perfcounter_conversion_functions(self) -> str:
    """Returns C functions converting enum values to groups/selectors."""
    selector_logic = "return perfcounter & ({}u - 1u);".format(
        2**ADRENO_MAX_NUM_COUNTER_BIT_PER_GROUP)
    group_logic = "return perfcounter >> {}u;".format(
        ADRENO_MAX_NUM_COUNTER_BIT_PER_GROUP)
    group_fn = ADRENO_ENUM_VALUE_TO_GROUP_FN.format(series=self.series,
                                                    group_logic=group_logic)
    selector_fn = ADRENO_ENUM_VALUE_TO_SELECTOR_DIRECT_FN.format(
        series=self.series, selector_logic=selector_logic)
    return group_fn + selector_fn + "\n"


@dataclass
class AdrenoAllSeriesDefinition:
  all_series: Tuple[AdrenoPerSeriesDefinition, AdrenoPerSeriesDefinition]

  def get_common_series(self):
    """Gets a "common" series with perfcounters available to all series."""
    if len(self.all_series) == 0:
      return AdrenoPerSeriesDefinition("common", {})

    common_groups = {}

    for candidate_group_name, candidate_group in self.all_series[
        0].groups.items():
      # Skip this entire group if it's missing in some GPU series.
      if not all([
          series.groups.get(candidate_group_name)
          for series in self.all_series[1:]
      ]):
        continue

      common_counters = {}
      for candidate_counter_symbol, candidate_counter in candidate_group.items(
      ):
        is_common_counter = True
        # Scan through all the other series to see whether their groups
        # contains the same counter.
        for series in self.all_series[1:]:
          group = series.groups[candidate_group_name]
          counter = group.get(candidate_counter_symbol)
          if counter is None:
            is_common_counter = False
            break
        if is_common_counter:
          common_counters[candidate_counter_symbol] = candidate_counter

      common_groups[candidate_group_name] = common_counters

    return AdrenoPerSeriesDefinition("common", common_groups)

  def get_perfcounter_conversion_functions(self) -> str:
    """Returns C functions converting enum values to groups/selectors."""
    functions = []
    common_series = self.get_common_series()
    for to_series in self.all_series:
      value_to_selector = []
      for common_group_name, common_group in common_series.groups.items():
        to_group = to_series.groups[common_group_name]
        for common_counter_symbol, _ in common_group.items():
          full_symbol = ADRENO_C_ENUM_CASE.format(
              series=common_series.series.upper(),
              group=common_group_name,
              symbol=common_counter_symbol)
          to_selector = to_group[common_counter_symbol].selector
          value_to_selector.append("case {}: return {};".format(
              full_symbol, to_selector))
      functions.append(
          ADRENO_ENUM_VALUE_TO_SELECTOR_SWITCH_FN.format(
              series=to_series.series, cases="\n    ".join(value_to_selector)))
    group_logic = "return perfcounter >> {}u;".format(
        ADRENO_MAX_NUM_COUNTER_BIT_PER_GROUP)
    group_fn = ADRENO_ENUM_VALUE_TO_GROUP_FN.format(series="common",
                                                    group_logic=group_logic)
    return group_fn + "".join(functions) + "\n"


def parse_xml_file(xml_path: str) -> AdrenoPerSeriesDefinition:
  """Parses the given XML file definining Adreno performance counters.

  The input XML file is expected to have the following structure:
  ```
  <database xmlns="http://nouveau.freedesktop.org/"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">
    <enum name="a6xx_<group>_perfcounter_select">
      <value value="0" name="PERF_<group>_<symbol>"/>
      <value value="1" name="PERF_<group>_<symbol>"/>
      ...
    </enum>
    ...
  </database>
  ```
  """
  series = os.path.splitext(os.path.basename(xml_path))[0]
  groups = {}

  tree = ET.parse(xml_path)
  root = tree.getroot()

  # First collect all perf counter groups' names and XML elements.
  acronyms = set(ADRENO_ACRONYMS)
  element_to_group_name_map = {}

  for enum in root.findall("nouveau:enum", ADRENO_XML_NS):
    enum_name = enum.get("name", "")
    if not enum_name.endswith("perfcounter_select"):
      continue
    if not enum_name.startswith(series):
      raise ValueError(f"enum '{enum_name}' is not for '{series}' series")

    # Get the group name from the enum name
    group_name = enum_name[len(series) + 1:-(len("perfcounter_select") + 1)]
    group_name = group_name.upper()

    acronyms.add(group_name)
    element_to_group_name_map[enum] = group_name

  for enum in root.findall("nouveau:enum", ADRENO_XML_NS):
    group_name = element_to_group_name_map.get(enum)
    group_cases = {}

    if group_name is None:
      continue

    for case in enum.findall("nouveau:value", ADRENO_XML_NS):
      selector = int(case.get("value"))
      symbol = case.get("name", "")
      # Drop the leading "PERF_" prefix if exists
      if symbol.startswith("PERF_"):
        symbol = symbol[len("PERF_"):]
      # Drop the leading group name prefix if exists
      if symbol.startswith(f"{group_name}_"):
        symbol = symbol[len(f"{group_name}_"):]
      # Get a nicer name string for this case from the symbol
      case_name = [(w if (len(w) <= 2 or w in acronyms) else w.lower())
                   for w in re.split(r"_+", symbol)]
      case_name = " ".join(case_name)
      group_cases[symbol] = AdrenoPerfCounter(case_name, symbol, selector)

    groups[group_name] = group_cases

  return AdrenoPerSeriesDefinition(series.lower(), groups)


def update_generated_file(autogen_file: str, updated_content: str):
  """Updates the autogen region in the given file to the new content."""
  with open(autogen_file, "r") as f:
    old_content = f.readlines()

  marker_lines = []
  for index, line in enumerate(old_content):
    if ADRENO_AUTOGEN_MARKER in line:
      marker_lines.append(index)
  if len(marker_lines) != 2:
    raise ValueError("Original content should contain two autogen markers!")

  new_content = []
  new_content.extend(old_content[:marker_lines[0] + 1])
  new_content.append(updated_content)
  new_content.extend(old_content[marker_lines[1]:])

  with open(autogen_file, "w") as f:
    f.write(''.join(new_content))


def parse_arguments():
  """Parses command-line options."""

  def check_file_path(path: str):
    if os.path.isfile(path):
      return path
    else:
      raise ValueError(f"{path} does not point to a file")

  parser = argparse.ArgumentParser()
  parser.add_argument(
      "--a5xx_xml",
      metavar="<adreno-xml-file>",
      type=check_file_path,
      required=True,
      help="Specify the XML file path containing Adreno A5xx definitions")
  parser.add_argument(
      "--a6xx_xml",
      metavar="<adreno-xml-file>",
      type=check_file_path,
      required=True,
      help="Specify the XML file path containing Adreno A6xx definitions")
  parser.add_argument("-o",
                      "--output",
                      metavar="<autogen-output-directory>",
                      required=True,
                      help="Specify the directory for generated files")
  args = parser.parse_args()

  return args


def main(args):
  a5xx_definition = parse_xml_file(args.a5xx_xml)
  a5xx_enum = a5xx_definition.get_all_perfcounters_as_one_enum()
  a5xx_c_header = os.path.join(args.output, a5xx_definition.series + ".h")
  update_generated_file(a5xx_c_header, a5xx_enum)
  a5xx_c_lib = os.path.join(args.output, a5xx_definition.series + ".c")
  update_generated_file(a5xx_c_lib,
                        a5xx_definition.get_perfcounter_conversion_functions())

  a6xx_definition = parse_xml_file(args.a6xx_xml)
  a6xx_enum = a6xx_definition.get_all_perfcounters_as_one_enum()
  a6xx_c_header = os.path.join(args.output, a6xx_definition.series + ".h")
  update_generated_file(a6xx_c_header, a6xx_enum)
  a6xx_c_lib = os.path.join(args.output, a6xx_definition.series + ".c")
  update_generated_file(a6xx_c_lib,
                        a6xx_definition.get_perfcounter_conversion_functions())

  # Generate files containing counters common to all known series
  all_series = AdrenoAllSeriesDefinition((a6xx_definition, a5xx_definition))

  common_definition = all_series.get_common_series()
  common_enum = common_definition.get_all_perfcounters_as_one_enum()
  common_c_header = os.path.join(args.output, common_definition.series + ".h")
  update_generated_file(common_c_header, common_enum)

  functions = all_series.get_perfcounter_conversion_functions()
  common_c_lib = os.path.join(args.output, common_definition.series + ".c")
  update_generated_file(common_c_lib, functions)


if __name__ == "__main__":
  main(parse_arguments())
