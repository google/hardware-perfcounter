#!/usr/bin/env python3

import argparse
import os

import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Dict, Optional, Sequence, Set, Tuple

# Omit Midgard Gen1/Gen2/Gen3 architectures: they are fairly old now.
PRODUCT_IGNORE_LIST = ["T60x", "T62x", "T72x", "T76x"]
LAYOUT_IGNORE_LIST = ["T60X", "T62X", "T72X", "T76X"]

MALI_AUTOGEN_MARKER = "AUTOGENERATED REGION; DO NOT EDIT!"

# Code templates for Mali counter layout definitions
MALI_LAYOUT_ENUM_PREFIX = "HPC_GPU_MALI_COUNTER_LAYOUT_"
MALI_LAYOUT_ENUM = """
/// Mali GPU counter layout schemes.
typedef enum hpc_gpu_mali_counter_layout_e {{
  {cases}
}} hpc_gpu_mali_counter_layout_t;
"""
MALI_GET_LAYOUT_FN = """
hpc_gpu_mali_counter_layout_t hpc_gpu_mali_get_layout(uint16_t gpu_id) {{
  {cases}
}}
"""

# Code templates for Mali counter definitions
MALI_COUNTER_ENUM = """
/// Common Mali {comment}GPU counters.
typedef enum hpc_gpu_mali_{group}_counter_e {{
  {cases}
}} hpc_gpu_mali_{group}_counter_t;
"""


@dataclass
class MaliProduct:
  """A data class containing one Mali product."""
  name: str  # Product name
  mask: str  # Product mask
  id: str  # Product ID (after applying mask)
  arch: str  # Product architecture
  layout: str  # Product perf counter layout

  def __str__(self):
    return f"{self.name}/{self.id} arch={self.arch} layout={self.layout}"


@dataclass
class MaliCounter:
  """A data class containing one Mali perf counter."""
  name: str  # Counter name
  index: int  # Counter index in the sample buffer

  def __str__(self):
    return f"[{self.index}] {self.name}"


@dataclass
class MaliLayout:
  """A data class containing one Mali perf counter layout."""
  name: str  # Layout name
  categories: Dict[str, Sequence[MaliCounter]]

  def __str__(self):
    lines = [f"Layout {self.name}"]
    for name, counters in self.categories.items():
      lines.extend(
          ["  {}{}".format(name, str(counter)) for counter in counters])
    return "\n".join(lines)


@dataclass
class MaliDatabase:
  """A data class containing the whole Mali product database."""
  products: Sequence[MaliProduct]
  layouts: Dict[str, MaliLayout]

  def __str__(self):
    lines = ["=== Products ==="]
    lines.extend([str(product) for product in self.products])
    lines.append("=== Layouts ===")
    lines.extend([str(layout) for layout in self.layouts.values()])
    return "\n".join(lines)

  def get_counter_layout_enum(self) -> str:
    """Returns a C enum containing all counter layouts."""
    cases = [f"{MALI_LAYOUT_ENUM_PREFIX}UNKNOWN"]
    cases.extend([
        "{}{}".format(MALI_LAYOUT_ENUM_PREFIX, l) for l in self.layouts.keys()
    ])
    return MALI_LAYOUT_ENUM.format(cases=",\n  ".join(cases))

  def get_counter_layout_fn(self) -> str:
    """Returns a function get the counter layout for a given GPU ID."""
    case_template = ("if ((gpu_id & {mask}u) == {id}u) "
                     "return {prefix}{layout};")
    cases = [
        case_template.format(mask=p.mask,
                             id=p.id,
                             layout=p.layout,
                             prefix=MALI_LAYOUT_ENUM_PREFIX)
        for p in reversed(self.products)
    ]
    cases.append(f"return {MALI_LAYOUT_ENUM_PREFIX}UNKNOWN;")
    return MALI_GET_LAYOUT_FN.format(cases="\n  ".join(cases))

  def _get_layouts_for_arch(self, arch: Optional[str] = None) -> Sequence[str]:
    """Gets the layouts for a specific architecture."""
    layouts = []
    for product in self.products:
      if (product.arch == arch) or (arch is None):
        layouts.append(product.layout)
    return layouts

  def _get_common_counter_for_layouts(
      self, layouts: Sequence[str]) -> Dict[str, Set[MaliCounter]]:
    """Returns a dict containing counters common to all Mali GPUs."""
    # Convert the (layout -> category) hierarchy into (category -> layout).
    categories = {}
    for layout_name in layouts:
      layout = self.layouts[layout_name]
      for name, category in layout.categories.items():
        if categories.get(name) is None:
          categories[name] = []
        categories[name].append([c.name for c in category])

    for name in categories.keys():
      category = categories[name]
      common_counters = []
      # Check all counters in the first layout to see whether they exist
      # in other layouts.
      for counter in category[0]:
        if all([(counter in other) for other in category[1:]]):
          common_counters.append(counter)
      categories[name] = common_counters

    return categories

  def get_common_counter_enum(self) -> str:
    """Returns C enums containing counters common to different GPU classes."""
    all_enums = ""

    counters = []
    layouts = self._get_layouts_for_arch(None)
    common_counters = self._get_common_counter_for_layouts(layouts)
    for name, category in common_counters.items():
      for counter in category:
        counters.append("_".join(["HPC_GPU_MALI_COMMON", name, counter]))
    all_enums += MALI_COUNTER_ENUM.format(comment="",
                                          group="common",
                                          cases=",\n  ".join(counters))

    counters = []
    layouts = self._get_layouts_for_arch("valhall")
    common_counters = self._get_common_counter_for_layouts(layouts)
    for name, category in common_counters.items():
      for counter in category:
        counters.append("_".join(["HPC_GPU_MALI_VALHALL", name, counter]))
    all_enums += MALI_COUNTER_ENUM.format(comment="Valhall ",
                                          group="valhall",
                                          cases=",\n  ".join(counters))

    counters = []
    layouts = self._get_layouts_for_arch("bifrost")
    common_counters = self._get_common_counter_for_layouts(layouts)
    for name, category in common_counters.items():
      for counter in category:
        counters.append("_".join(["HPC_GPU_MALI_BIFROST", name, counter]))
    all_enums += MALI_COUNTER_ENUM.format(comment="Bifrost ",
                                          group="bifrost",
                                          cases=",\n  ".join(counters))

    return all_enums


def parse_xml_file(xml_path: str) -> MaliDatabase:
  """Parses the given XML file containg the Mali product database.

  The input XML file is expected to have the following structure:
  ```
  <database>
    <products>
      <product name="G78"   mask="0xf00f" id="0x9002"
               architecture="valhall" layout="TBOX" />
      ...
    </products>
    <layouts>
      <layout name="TBOX">
        <category name="SHADER_CORE">
          <counter index="...", name="...">
          ...
        </category>
      </layout>
      ...
    </layouts>
  </database>
  ```
  """
  tree = ET.parse(xml_path)
  root = tree.getroot()

  xml_products = root.find("products")
  xml_layouts = root.find("layouts")

  # Collect all GPU products.
  products = []
  for product in xml_products.findall("product"):
    if product.get("name") in PRODUCT_IGNORE_LIST:
      continue
    products.append(
        MaliProduct(name=product.get("name"),
                    mask=product.get("mask"),
                    id=product.get("id"),
                    arch=product.get("architecture"),
                    layout=product.get("layout")))

  # Collect all perf counter layouts
  layouts = {}
  for layout in xml_layouts.findall("layout"):
    name = layout.get("name")
    if name in LAYOUT_IGNORE_LIST:
      continue
    categories = {}
    for category in layout.findall("category"):
      counters = []
      for counter in category.findall("counter"):
        counters.append(
            MaliCounter(name=counter.get("name"), index=counter.get("index")))
      categories[category.get("name")] = counters
    layouts[name] = MaliLayout(name, categories)

  return MaliDatabase(products=products, layouts=layouts)


def update_generated_file(autogen_file: str, updated_content: str):
  """Updates the autogen region in the given file to the new content."""
  with open(autogen_file, "r") as f:
    old_content = f.readlines()

  marker_lines = []
  for index, line in enumerate(old_content):
    if MALI_AUTOGEN_MARKER in line:
      marker_lines.append(index)
  if len(marker_lines) != 2:
    raise ValueError("Original content should contain two autogen markers!")

  new_content = []
  new_content.extend(old_content[:marker_lines[0] + 1])
  new_content.append(updated_content)
  new_content.extend(old_content[marker_lines[1]:])

  with open(autogen_file, "w") as f:
    f.write(''.join(new_content))


def parse_arguments():
  """Parses command-line options."""

  def check_file_path(path: str):
    if os.path.isfile(path):
      return path
    else:
      raise ValueError(f"{path} does not point to a file")

  parser = argparse.ArgumentParser()
  parser.add_argument(
      "--mali_xml",
      metavar="<mali-xml-file>",
      type=check_file_path,
      required=True,
      help="Specify the XML file path containing Mali product database")
  parser.add_argument("-o",
                      "--output",
                      metavar="<autogen-output-directory>",
                      required=True,
                      help="Specify the directory for generated files")
  args = parser.parse_args()

  return args


def main(args):
  db = parse_xml_file(args.mali_xml)
  product_header = os.path.join(args.output, "product.h")
  update_generated_file(product_header, db.get_counter_layout_enum() + "\n")
  product_lib = os.path.join(args.output, "product.c")
  update_generated_file(product_lib, db.get_counter_layout_fn() + "\n")
  common_header = os.path.join(args.output, "common.h")
  update_generated_file(common_header, db.get_common_counter_enum() + "\n")


if __name__ == "__main__":
  main(parse_arguments())
